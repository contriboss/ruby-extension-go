package rubyext

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// Ruby command constant
const (
	rubyCommand = "ruby"
)

// RakeBuilder handles Ruby-based builds using Rakefile or mkrf_conf
type RakeBuilder struct{}

// Name returns the builder name
func (b *RakeBuilder) Name() string {
	return "Rake"
}

// RequiredTools returns the tools needed for Rake builds
func (b *RakeBuilder) RequiredTools() []ToolRequirement {
	return []ToolRequirement{
		{
			Name:    "ruby",
			Purpose: "Ruby interpreter",
		},
		{
			Name:     "rake",
			Optional: true,
			Purpose:  "Ruby build tool (usually bundled with Ruby)",
		},
	}
}

// CheckTools verifies that Ruby and Rake are available
func (b *RakeBuilder) CheckTools() error {
	return CheckRequiredTools(b.RequiredTools())
}

// CanBuild checks if this builder can handle the extension file
func (b *RakeBuilder) CanBuild(extensionFile string) bool {
	filename := strings.ToLower(filepath.Base(extensionFile))
	return MatchesPattern(filename, `rakefile$`) ||
		MatchesPattern(filename, `rakefile\.rb$`) ||
		MatchesPattern(filename, `mkrf_conf$`) ||
		MatchesPattern(filename, `mkrf_conf\.rb$`)
}

// Build compiles the extension using rake
func (b *RakeBuilder) Build(ctx context.Context, config *BuildConfig, extensionFile string) (*BuildResult, error) {
	result := &BuildResult{
		Success: false,
		Output:  []string{},
	}

	extensionPath := filepath.Join(config.GemDir, extensionFile)
	extensionDir := filepath.Dir(extensionPath)

	// Handle mkrf_conf files differently - they generate Rakefiles
	if b.isMkrfConf(extensionFile) {
		if err := b.runMkrfConf(ctx, config, extensionDir, extensionFile, result); err != nil {
			result.Error = err
			return result, err
		}
	}

	// Run rake to build the extension
	if err := b.runRake(ctx, config, extensionDir, result); err != nil {
		result.Error = err
		return result, err
	}

	// Find built extensions
	extensions, err := b.findBuiltExtensions(extensionDir)
	if err != nil {
		result.Error = err
		return result, err
	}

	finalized, err := finalizeNativeExtensions(config, extensionFile, extensionDir, extensions)
	if err != nil {
		result.Error = err
		return result, err
	}

	result.Extensions = finalized
	result.Success = true
	return result, nil
}

// Clean removes build artifacts
func (b *RakeBuilder) Clean(ctx context.Context, config *BuildConfig, extensionFile string) error {
	extensionPath := filepath.Join(config.GemDir, extensionFile)
	extensionDir := filepath.Dir(extensionPath)

	// Try rake clean task
	cmd := exec.CommandContext(ctx, "rake", "clean")
	cmd.Dir = extensionDir

	// Set environment for Ruby/rake
	cmd.Env = os.Environ()
	if config.RubyPath != "" {
		// Ensure rake uses the correct Ruby
		rubyDir := filepath.Dir(config.RubyPath)
		cmd.Env = append(cmd.Env, fmt.Sprintf("PATH=%s:%s", rubyDir, os.Getenv("PATH")))
	}

	return cmd.Run() // Ignore errors, clean is best-effort
}

// isMkrfConf checks if this is an mkrf_conf file
func (b *RakeBuilder) isMkrfConf(extensionFile string) bool {
	filename := strings.ToLower(filepath.Base(extensionFile))
	return MatchesPattern(filename, `mkrf_conf`) || MatchesPattern(filename, `mkrf_conf\.rb`)
}

// runMkrfConf executes mkrf_conf.rb to generate a Rakefile
func (b *RakeBuilder) runMkrfConf(ctx context.Context, config *BuildConfig, extensionDir, extensionFile string, result *BuildResult) error {
	rubyPath := config.RubyPath
	if rubyPath == "" {
		rubyPath = rubyCommand
	}

	mkrfPath := filepath.Join(extensionDir, filepath.Base(extensionFile))

	cmd := exec.CommandContext(ctx, rubyPath, mkrfPath)
	cmd.Dir = extensionDir

	// Set environment variables
	cmd.Env = os.Environ()
	for key, value := range config.Env {
		cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", key, value))
	}

	output, err := cmd.CombinedOutput()
	outputLines := strings.Split(string(output), "\n")
	result.Output = append(result.Output, outputLines...)

	if config.Verbose {
		result.Output = append(result.Output,
			fmt.Sprintf("Running: %s %s", rubyPath, mkrfPath),
			fmt.Sprintf("Working directory: %s", extensionDir))
	}

	if err != nil {
		return BuildError("mkrf_conf", result.Output, err)
	}

	// Verify Rakefile was created
	rakefilePath := filepath.Join(extensionDir, "Rakefile")
	if _, err := os.Stat(rakefilePath); os.IsNotExist(err) {
		return BuildError("mkrf_conf", result.Output, fmt.Errorf("rakefile not generated by mkrf_conf"))
	}

	return nil
}

// runRake executes rake to build the extension
func (b *RakeBuilder) runRake(ctx context.Context, config *BuildConfig, extensionDir string, result *BuildResult) error {
	// Build rake arguments
	args := []string{}

	// Add parallel jobs if specified and rake supports it
	if config.Parallel > 0 {
		args = append(args, fmt.Sprintf("--jobs=%d", config.Parallel))
	}

	// Clean first if requested
	if config.CleanFirst {
		cleanCmd := exec.CommandContext(ctx, "rake", "clean")
		cleanCmd.Dir = extensionDir
		cleanOutput, _ := cleanCmd.CombinedOutput()
		result.Output = append(result.Output, strings.Split(string(cleanOutput), "\n")...)
	}

	// Add any custom build args
	args = append(args, config.BuildArgs...)

	cmd := exec.CommandContext(ctx, "rake", args...)
	cmd.Dir = extensionDir

	// Set environment variables
	cmd.Env = os.Environ()
	for key, value := range config.Env {
		cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", key, value))
	}

	// Ensure rake uses the correct Ruby
	if config.RubyPath != "" {
		rubyDir := filepath.Dir(config.RubyPath)
		// Prepend Ruby's bin directory to PATH
		currentPath := os.Getenv("PATH")
		newPath := fmt.Sprintf("%s:%s", rubyDir, currentPath)
		cmd.Env = append(cmd.Env,
			fmt.Sprintf("PATH=%s", newPath),
			fmt.Sprintf("RUBY=%s", config.RubyPath))
	}

	// Set other Ruby-related environment variables
	if config.RubyEngine != "" {
		cmd.Env = append(cmd.Env, fmt.Sprintf("RUBY_ENGINE=%s", config.RubyEngine))
	}
	if config.RubyVersion != "" {
		cmd.Env = append(cmd.Env, fmt.Sprintf("RUBY_VERSION=%s", config.RubyVersion))
	}

	output, err := cmd.CombinedOutput()
	outputLines := strings.Split(string(output), "\n")
	result.Output = append(result.Output, outputLines...)

	if config.Verbose {
		result.Output = append(result.Output,
			fmt.Sprintf("Running: rake %s", strings.Join(args, " ")),
			fmt.Sprintf("Working directory: %s", extensionDir))
	}

	if err != nil {
		return BuildError("Rake", result.Output, err)
	}

	return nil
}

// findBuiltExtensions locates the compiled extension files
func (b *RakeBuilder) findBuiltExtensions(extensionDir string) ([]string, error) {
	var extensions []string

	// Common extension file patterns
	patterns := []string{
		"*.so",     // Linux/Unix shared libraries
		"*.bundle", // macOS bundles
		"*.dll",    // Windows dynamic libraries
		"lib/*.so", // Extensions might be in lib subdirectory
		"lib/*.bundle",
		"lib/*.dll",
		"ext/*.so", // Or in ext subdirectory
		"ext/*.bundle",
		"ext/*.dll",
	}

	for _, pattern := range patterns {
		matches, err := filepath.Glob(filepath.Join(extensionDir, pattern))
		if err != nil {
			return nil, fmt.Errorf("failed to glob pattern %s in %s: %v", pattern, extensionDir, err)
		}

		for _, match := range matches {
			// Convert to relative path
			relPath, err := filepath.Rel(extensionDir, match)
			if err == nil {
				extensions = append(extensions, relPath)
			}
		}
	}

	return extensions, nil
}
