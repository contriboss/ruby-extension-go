package rubyext

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
)

// ConfigureBuilder handles autotools-style configure scripts
type ConfigureBuilder struct{}

// Name returns the builder name
func (b *ConfigureBuilder) Name() string {
	return "Configure"
}

// RequiredTools returns the tools needed for configure-based builds
func (b *ConfigureBuilder) RequiredTools() []ToolRequirement {
	return []ToolRequirement{
		{
			Name:         "sh",
			Alternatives: []string{"bash", "dash"},
			Purpose:      "Shell to execute configure script",
		},
		{
			Name:         "gcc",
			Alternatives: []string{"clang", "cc"},
			Purpose:      "C/C++ compiler",
		},
		{
			Name:         "make",
			Alternatives: []string{"gmake"},
			Purpose:      "Build automation tool",
		},
	}
}

// CheckTools verifies that shell and make are available
func (b *ConfigureBuilder) CheckTools() error {
	return CheckRequiredTools(b.RequiredTools())
}

// CanBuild checks if this builder can handle the extension file
func (b *ConfigureBuilder) CanBuild(extensionFile string) bool {
	return MatchesPattern(extensionFile, `configure$`) || MatchesPattern(extensionFile, `configure\.sh$`)
}

// Build compiles the extension using the ./configure â†’ make workflow
func (b *ConfigureBuilder) Build(ctx context.Context, config *BuildConfig, extensionFile string) (*BuildResult, error) {
	result := &BuildResult{
		Success: false,
		Output:  []string{},
	}

	extensionPath := filepath.Join(config.GemDir, extensionFile)
	extensionDir := filepath.Dir(extensionPath)

	// Step 1: Run ./configure to generate Makefile
	if err := b.runConfigure(ctx, config, extensionDir, extensionFile, result); err != nil {
		result.Error = err
		return result, err
	}

	// Step 2: Run make to compile the extension
	if err := b.runMake(ctx, config, extensionDir, result); err != nil {
		result.Error = err
		return result, err
	}

	// Step 3: Find built extensions
	extensions, err := b.findBuiltExtensions(extensionDir)
	if err != nil {
		result.Error = err
		return result, err
	}

	result.Extensions = extensions
	result.Success = true
	return result, nil
}

// Clean removes build artifacts
func (b *ConfigureBuilder) Clean(ctx context.Context, config *BuildConfig, extensionFile string) error {
	extensionPath := filepath.Join(config.GemDir, extensionFile)
	extensionDir := filepath.Dir(extensionPath)

	makefilePath := filepath.Join(extensionDir, "Makefile")
	if _, err := os.Stat(makefilePath); os.IsNotExist(err) {
		return nil // Nothing to clean
	}

	makeProgram := b.getMakeProgram()

	// Try "make distclean" first (autotools standard), then "make clean"
	distcleanCmd := exec.CommandContext(ctx, makeProgram, "distclean")
	distcleanCmd.Dir = extensionDir
	if err := distcleanCmd.Run(); err != nil {
		// Fall back to regular clean
		cleanCmd := exec.CommandContext(ctx, makeProgram, "clean")
		cleanCmd.Dir = extensionDir
		return cleanCmd.Run()
	}

	return nil
}

// runConfigure executes the configure script
func (b *ConfigureBuilder) runConfigure(
	ctx context.Context, config *BuildConfig, extensionDir, extensionFile string, result *BuildResult,
) error {
	configurePath := filepath.Join(extensionDir, filepath.Base(extensionFile))

	// Make sure configure script is executable
	if err := os.Chmod(configurePath, 0755); err != nil {
		return BuildError("Configure", result.Output, fmt.Errorf("failed to make configure executable: %v", err))
	}

	// Build configure arguments
	args := []string{}

	// Add prefix if dest path is specified
	if config.DestPath != "" {
		args = append(args, fmt.Sprintf("--prefix=%s", config.DestPath))
	}

	// Add any custom build args
	args = append(args, config.BuildArgs...)

	cmd := exec.CommandContext(ctx, configurePath, args...)
	cmd.Dir = extensionDir

	// Set environment variables
	cmd.Env = os.Environ()
	for key, value := range config.Env {
		cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", key, value))
	}

	// Common autotools environment variables
	if config.RubyPath != "" {
		cmd.Env = append(cmd.Env, fmt.Sprintf("RUBY=%s", config.RubyPath))
	}

	output, err := cmd.CombinedOutput()
	outputLines := strings.Split(string(output), "\n")
	result.Output = append(result.Output, outputLines...)

	if config.Verbose {
		result.Output = append(result.Output,
			fmt.Sprintf("Running: %s %s", configurePath, strings.Join(args, " ")),
			fmt.Sprintf("Working directory: %s", extensionDir))
	}

	if err != nil {
		return BuildError("Configure", result.Output, err)
	}

	// Verify Makefile was created
	makefilePath := filepath.Join(extensionDir, "Makefile")
	if _, err := os.Stat(makefilePath); os.IsNotExist(err) {
		return BuildError("Configure", result.Output, fmt.Errorf("makefile not generated by configure"))
	}

	return nil
}

// runMake executes make to compile the extension
func (b *ConfigureBuilder) runMake(ctx context.Context, config *BuildConfig, extensionDir string, result *BuildResult) error {
	makeProgram := b.getMakeProgram()

	// Build make arguments
	args := []string{}

	// Add parallel jobs if specified
	if config.Parallel > 0 {
		args = append(args, fmt.Sprintf("-j%d", config.Parallel))
	}

	// Clean first if requested
	if config.CleanFirst {
		cleanCmd := exec.CommandContext(ctx, makeProgram, "clean")
		cleanCmd.Dir = extensionDir
		cleanOutput, _ := cleanCmd.CombinedOutput()
		result.Output = append(result.Output, strings.Split(string(cleanOutput), "\n")...)
	}

	// Run make
	cmd := exec.CommandContext(ctx, makeProgram, args...)
	cmd.Dir = extensionDir

	// Set environment variables
	cmd.Env = os.Environ()
	for key, value := range config.Env {
		cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", key, value))
	}

	output, err := cmd.CombinedOutput()
	outputLines := strings.Split(string(output), "\n")
	result.Output = append(result.Output, outputLines...)

	if config.Verbose {
		result.Output = append(result.Output,
			fmt.Sprintf("Running: %s %s", makeProgram, strings.Join(args, " ")),
			fmt.Sprintf("Working directory: %s", extensionDir))
	}

	if err != nil {
		return BuildError("Make", result.Output, err)
	}

	// Run make install if dest path is specified
	if config.DestPath != "" {
		installCmd := exec.CommandContext(ctx, makeProgram, "install")
		installCmd.Dir = extensionDir
		installCmd.Env = cmd.Env

		installOutput, err := installCmd.CombinedOutput()
		installLines := strings.Split(string(installOutput), "\n")
		result.Output = append(result.Output, installLines...)

		if err != nil {
			return BuildError("Make Install", result.Output, err)
		}
	}

	return nil
}

// findBuiltExtensions locates the compiled extension files
func (b *ConfigureBuilder) findBuiltExtensions(extensionDir string) ([]string, error) {
	var extensions []string

	// Common extension file patterns for autotools builds
	patterns := []string{
		"*.so",       // Linux/Unix shared libraries
		"*.bundle",   // macOS bundles
		"*.dll",      // Windows dynamic libraries
		"*.dylib",    // macOS dynamic libraries
		".libs/*.so", // Libtool output directory
		".libs/*.dylib",
		".libs/*.dll",
	}

	for _, pattern := range patterns {
		matches, err := filepath.Glob(filepath.Join(extensionDir, pattern))
		if err != nil {
			return nil, fmt.Errorf("failed to glob pattern %s in %s: %v", pattern, extensionDir, err)
		}

		for _, match := range matches {
			// Convert to relative path
			relPath, err := filepath.Rel(extensionDir, match)
			if err == nil {
				extensions = append(extensions, relPath)
			}
		}
	}

	return extensions, nil
}

// getMakeProgram returns the appropriate make program for the platform
func (b *ConfigureBuilder) getMakeProgram() string {
	// Check environment variable first
	if makeProgram := os.Getenv("MAKE"); makeProgram != "" {
		return makeProgram
	}

	// Platform-specific defaults
	switch runtime.GOOS {
	case platformWindows:
		return makeProgram // Most Windows autotools use MinGW/MSYS2 make
	default:
		return makeProgram
	}
}
